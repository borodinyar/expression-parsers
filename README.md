# Парсеры выражений

## Оглавление

* [Java](#java)  
  * [Выражения](#выражения)  
  * [Разбор выражений](#разбор-выражений)  
  * [Обработка ошибок](#обработка-ошибок)
  * [Вычисление в различных типах](#вычисление-в-различных-типах)
* [JavaScript](#javascript)  
  * [Объектные выражения на JavaScript](#объектные-выражения-на-javascript)
  * [Обработка ошибок на JavaScript](#обработка-ошибок-на-javascript)
* [Clojure](#clojure)  
  * [Функциональные выражения на Clojure](#функциональные-выражения-на-clojure)
  * [Объектные выражения на Clojure](#объектные-выражения-на-clojure)
  * [Комбинаторные парсеры](комбинаторные-парсеры)
* [Prolog](#prolog)  
  * [Разбор выражений на Prolog](разбор-выражений-на-prolog)


## Java

### Выражения 

* Разработайте классы _Const_, _Variable_, _Add_, _Subtract_, _Multiply_, _Divide_ для вычисления выражений с одной переменной в типе _int_.

* Классы должны позволять составлять выражения вида
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).evaluate(5)
```
            
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу _evaluate_ (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число ***7***.

* Метод _toString_ должен выдавать запись выражения в полноскобочной форме. Например
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toString()
```
            
должен выдавать ***((2 * x) - 3)***.

* Метод _toMiniString_ должен выдавать выражение с минимальным числом скобок. Например
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toMiniString()
```
должен выдавать ***2 * x - 3***.

* Реализуйте метод _equals_, проверяющий, что два выражения совпадают. Например,
```
new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Const(2), new Variable("x")))
```
            
должно выдавать ***true***, а
```
new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Variable("x"), new Const(2)))
```
            
должно выдавать ***false***.

* Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения _x2−2x+1_, для _x_, заданного в командной строке.
> При выполнении задания следует обратить внимание на:  
> * Выделение общего интерфейса создаваемых классов.  
> * Выделение абстрактного базового класса для бинарных операций.

---

### Разбор выражений 

* Доработайте предыдущее задание, так что бы выражение строилось по записи вида
  _x * (x - 2)*x + 1_  

* В записи выражения могут встречаться: умножение \*, деление \/, сложение \+, вычитание \-, унарный минус \-, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные (x) и произвольное число пробельных символов в любом месте (но не внутри констант).

* Приоритет операторов, начиная с наивысшего
  * унарный минус;
  * умножение и деление;
  * сложение и вычитание.

> Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://ru.wikibooks.org/wiki/Реализации_алгоритмов/Метод_рекурсивного_спуска).
> Алгоритм должен работать за линейное время.

---

### Обработка ошибок

* Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
  * ошибки разбора выражений;
  * ошибки вычисления выражений.


* Для выражения _1000000\*x\*x\*x\*x\*x\/(x-1)_ вывод программы должен иметь следующий вид:
```
x       f
0       0
1       division by zero
2       32000000
3       121500000
4       341333333
5       overflow
6       overflow
7       overflow
8       overflow
9       overflow
10      overflow
```

Результат _division by zero (overflow)_ означает, что в процессе вычисления произошло деление на ноль (переполнение).

> При выполнении задания следует обратить внимание на дизайн и обработку исключений.  
> Человеко-читаемые сообщения об ошибках должны выводится на консоль.  
> Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

---

### Вычисление в различных типах

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

* Создайте класс _expression.generic.GenericTabulator_, реализующий интерфейс _expression.generic.Tabulator_:
```
   public interface Tabulator {
       Object[][][] tabulate(String mode, String expression, int x1, int x2, int y1, int y2, int z1, int z2) throws Exception;
   }
```

  Аргументы

  * mode — режим работы

    | Режим	| Тип |  
    |:-----:|:---------------------------:|  
    | i	| int (с детекцией переполнений)|  
    | d	| double|  
    | bi | [BigInteger](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html)|  

  * expression — вычисляемое выражение;
  * x1, x2; y1, y2; z1, z2 — диапазоны изменения переменны (включительно).

  Возвращаемое значение — таблица значений функции, где _R[i][j][k]_ соответствует _x = x1 \+ i_, _y = y1 \+ j_, _z = z1 \+ k_. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть ***null***.

* Доработайте интерфейс командной строки:
  * Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:

    Опция	| Тип  
    :--: | :--------:
    i	| int (с детекцией переполнений)  
    d	| double  
    bi	| [BigInteger](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html)  

  * Вторым аргументом командной строки программа должна принимать выражение для вычисления.
  * Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
> Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.9).  
> Реализация не должна использовать аннотацию [@SuppressWarnings](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.6.4.5).  
> При выполнении задания следует обратить внимание на простоту добавления новых типов и операциий.

[:arrow_up:Оглавление](#оглавление)
___


## JavaScript

### Объектные выражения на JavaScript

* Разработайте классы _Const_, _Variable_, _Add_, _Subtract_, _Multiply_, _Divide_, _Negate_ для представления выражений с одной переменной.
    * Пример описания выражения _2x-3_:
    ```
    let expr = new Subtract(
        new Multiply(
            new Const(2),
            new Variable("x")
        ),
        new Const(3)
    );

    println(expr.evaluate(5));
    ```

  * При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода _evaluate_. Таким образом, результатом вычисления приведенного примера должно стать число ***7***.
  * Метод _toString()_ должен выдавать запись выражения в обратной польской записи. Например, _expr.toString()_ должен выдавать ***«2 x * 3 -»***.

* Метод _diff("x")_ должен возвращать выражение, представляющее производную исходного выражения по переменной _x_. Например, _expr.diff("x")_ должен возвращать выражение, эквивалентное new ```Const(2)``` (выражения ```new Subtract(new Const(2), new Const(0)```) и
  ```
  new Subtract(
      new Add(
          new Multiply(new Const(0), new Variable("x")),
          new Multiply(new Const(2), new Const(1))
      )
      new Const(0)
  )
  ```

  так же будут считаться правильным ответом).
  
* Функция _parse_ должна выдавать разобранное объектное выражение.

> При выполнение задания следует обратить внимание на:
> * Применение инкапсуляции.
> * Выделение общего кода для операций.
> * Минимизацию необходимой памяти.

---

### Обработка ошибок на JavaScript

* Добавьте в предыдущее задание функцию _parsePrefix(string)_, разбирающую выражения, задаваемые записью вида _«(- (* 2 x) 3)»_. Если разбираемое выражение некорректно, метод _parsePrefix_ должен бросать человеко-читаемое сообщение об ошибке.

* Добавьте в предыдущее задание метод _prefix()_, выдающий выражение в формате, ожидаемом функцией _parsePrefix_.
 
> При выполнение задания следует обратить внимание на:
> * Применение инкапсуляции.
> * Выделение общего кода для операций.
> * Минимизацию необходимой памяти.
> * Обработку ошибок.

[:arrow_up:Оглавление](#оглавление)
___


## Clojure

### Функциональные выражения на Clojure

* Разработайте функции _constant_, _variable_, _add_, _subtract_, _multiply_ и _divide_ для представления арифметических выражений.
  * Пример описания выражения _2x-3_:
  ```
  (def expr
    (subtract
      (multiply
        (constant 2)
        (variable "x"))
      (constant 3)))
   ```

  * Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, ```(expr {"x" 2})``` должно быть равно ***1***.

* Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,  
  ```(parseFunction "(- (* 2 x) 3)")```  
  должно быть эквивалентно ***expr***.

* Функции _add_, _subtract_, _multiply_ и _divide_ должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*, \/.

> При выполнение задания следует обратить внимание на:
> * Выделение общего кода для операций.

---

### Объектные выражения на Clojure

* Разработайте конструкторы _Constant_, _Variable_, _Add_, _Subtract_, _Multiply_ и _Divide_ для представления выражений с одной переменной.  
  * Пример описания выражения _2x-3_:
  ```
  (def expr
    (Subtract
      (Multiply
        (Constant 2)
        (Variable "x"))
      (Constant 3)))
  ```

  * Функция ```(evaluate expression vars)``` должна производить вычисление выражения _expression_ для значений переменных, заданных отображением _vars_. Например,   
  ```(evaluate expr {"x" 2})```  
  должно быть равно ***1***.
    
  * Функция ```(toString expression)``` должна выдавать запись выражения в стандартной для Clojure форме.

  * Функция ```(parseObject "expression")``` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
  ```(parseObject "(- (* 2 x) 3)")```
  должно быть эквивалентно ***expr***.
  
  * Функция ```(diff expression "variable")``` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, ```(diff expression "x")``` должен возвращать выражение, эквивалентное ```(Constant 2)```, при этом выражения ```(Subtract (Constant 2) (Constant 0))``` и
  ```
  (Subtract
    (Add
      (Multiply (Constant 0) (Variable "x"))
      (Multiply (Constant 2) (Constant 1)))
    (Constant 0))
  ```
  так же будут считаться правильным ответом.

* Констуркторы _Add_, _Subtract_, _Multiply_ и _Divide_ должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для \+, \-, \*, \/.

> При выполнение задания можно использовать любой способ преставления объектов.

---

### Комбинаторные парсеры

Реализуйте функцию ```(parseObjectInfix "expression")```, разбирающую выражения, записанные в инфиксной форме, и функцию _toStringInfix_, возвращающую строковое представление выражения в этой форме. Например,  
```(toStringInfix (parseObjectInfix "2 * x - 3"))```  
должно возвращать ***((2 * x) - 3)***.

> Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

[:arrow_up:Оглавление](#оглавление)
___


## Prolog

### Разбор выражений на Prolog

* Доработайте правило ```(evaluate Expression Varsiables Result)```, вычисляющее арифметические выражения.
  * Пример вычисления выражения 2x-3 для x = 5:
  ```
  eval(
      operation(op_subtract,
          operation(op_multiply,
              const(2),
              variable(x)
          ),
          const(3)
      ),
      [(x, 5)],
      7
  )
  ```

  * Поддерживаемые операции: сложение ```(op_add, +)```, вычитание ```(op_subtract, -)```, умножение ```(op_multiply, *)```, деление ```(op_divide, /)```, противоположное число ```(op_negate, negate)```.

* Реализуйте правило ```(infix_str Expression Atom)```, разбирающее/выводящее выражения, записанные в полноскобочной инфиксной форме. Например,
    ```
    infix_str(
        operation(op_subtract,operation(op_multiply,const(2),variable(x)),const(3)),
        '((2 * x) - 3)'
    )
    ```

> Правила должны быть реализованы с применением DC-грамматик.

[:arrow_up:Оглавление](#оглавление)
